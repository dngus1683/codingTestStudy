# 구현 (Implementation)
구현(Implementation) 알고리즘은 주어진 문제를 코드로 직접 구현하여 해결하는 알고리즘 기법을 말한다. 주어진 문제를 정확하게 이해하고, 알고리즘을 코드로 옮기는 과정이 포함된다. 구현은 문제에 대한 이해와 코드 작성 능력을 기르는 데에 중요한 역할을 한다.

## Algorithm
대표적인 구현 유형으로는 '**완전 탐색**'과 '**시뮬레이션**' 유형 등이 있다.

#### 1. 완전 탐색

완전 탐색은 모든 가능한 경우의 수를 검사하여 해답을 찾는 방법이다. 모든 경우의 수를 순회하며 문제의 조건을 만족하는지 확인하는 방식으로 동작한다. 보통 시간 복잡도가 높지만, 경우에 따라서는 최적의 해답을 구할 수 있다.

  1. 주어진 문제의 모든 가능한 경우의 수를 생성한다.
  2. 각 경우에 대해 조건을 만족하는지 확인한다.
  3. 조건을 만족하는 경우 해답으로 선택한다.

#### 2. 시뮬레이션

시뮬레이션은 주어진 상황을 모의하여 원하는 결과를 얻는 방법이다. 주어진 문제를 단계 별로 직접 수행해 보면서 해답을 찾아간다.
  
  1. 주어진 상황을 모의한다.
  2. 각 단계를 진행하며 상황을 업데이트한다.
  3. 원하는 결과를 얻을 때까지 반복한다.

#### 3. 비둘기집 원리(Pigeonhole Principle)

 수학의 기초적인 원리 중 하나로, 때때로 자명하게 보이지만 매우 강력한 논리적 도구로 사용된다. 이 원리는 다음과 같은 형태로 표현된다:

만약 n개의 비둘기를 m개의 비둘기집에 넣을 때, n>𝑚 이라면 적어도 하나의 비둘기집에는 두 개 이상의 비둘기가 들어가게 된다.

이를 활용하면, 자명한 사실을 활용해 불필요한 계산을 줄일 수 있는 경우도 있다.

**예시)**
  1. 만약 10명의 학생이 9개의 사물함을 사용해야 한다면, 적어도 하나의 사물함에는 두 명 이상의 학생이 사용하게 된다.
  2. 응용 예시: 13명의 사람에게 생일을 물어보면, 적어도 두 명 이상이 같은 달에 생일을 가질 것이다. (12개월보다 사람이 더 많기 때문)


## Pseudocode

#### 완전탐색
```
function BruteForce():
    for each possible solution:
        if solution satisfies conditions:
            return solution
    return no solution
```

#### 시뮬레이션
```
function Simulation():
    initialize simulation environment
    while not desired_result:
        simulate next step
        update environment
    return final_result
```

## 고려해야 할 사항
**1. 메모리 제한 고려:**
+ 자료형 크기 설명: 자료형의 크기를 고려하여 메모리를 효율적으로 사용해야 한다. 예를 들어, int에 담기지 않는 큰 정수형 변수를 사용할 때는 int보다 큰 자료형인 long long 자료형을 고려하여야 한다.
+ 알고리즘 문제를 풀 때, C++의 경우 배열의 크기를 고려해야 한다. [백준](https://www.acmicpc.net/)을 예로 들자면, int 형 배열은 최대 1억까지의 크기를 전역 변수로 선언이 가능하다. 그 이상을 사용하고 싶다면 vector를 사용하거나 동적 할당을 사용해야 한다.

**2. 시간 제한 고려:**
+ 알고리즘의 시간 복잡도를 고려하여 효율적인 알고리즘을 선택하여 시간 제한을 초과하지 않는 알고리즘을 설계해야 한다.
+ 입출력 함수 처리 시간 비교 및 활용 방안: C++에서는 cin, cout을 사용할 때 입출력 함수 처리 시간이 느릴 수 있습니다. 이를 개선하기 위해 ios_base::sync_with_stdio(false); cin.tie(0)를 사용하여 입출력 속도를 향상시킬 수 있다.
  
  ios_base::sync_with_stdio(false);와 cin.tie(0);는 C++에서 입출력 속도를 개선하기 위한 기법이다. 기본적으로 C++의 cin과 cout은 C의 stdio를 사용하는 것과 동기화되어 있다. 이는 입력과 출력이 동기화되어 있어서 입출력이 빈번한 경우에는 속도가 느려질 수 있다. 따라서 입출력 속도를 개선하기 위해 사용된다.
  
  **ios_base::sync_with_stdio(false);** 는 C++의 iostream과 C의 stdio를 동기화하지 않도록 설정하는 명령이다. 이 명령을 사용하면 cin과 cout이 내부 버퍼링을 사용하게 되어 입출력 속도가 향상된다. 하지만 이 설정을 사용하면 scanf와 printf 등을 혼용할 수없게 된다.

  **cin.tie(0);** 는 cin과 cout의 묶음을 풀어주는 역할을 한다. 기본적으로 cin은 cout과 묶여있어서 출력 버퍼를 비우기 전에 입력 버퍼를 비우게 된다. 이로 인해 입출력의 순서가 보장되어야 하는 상황에서 속도 저하가 발생할 수 있다. cin.tie(0);를 사용하면 cin과 cout이 묶임을 풀어주어서 이러한 문제를 해결할 수 있다.
    
