# 그리디 알고리즘 (Greedy Algorithm)
그리디 알고리즘(Greedy Algorithm)은 각 단계에서 최적의 선택을 하는 탐욕스러운 방법을 사용하여 문제를 해결하는 알고리즘 기법이다. 각 단계에서 가장 최적인 선택을 하며 이 선택을 계속 수행하여 최종적으로 전체적인 최적해를 찾는다. 그리디 알고리즘은 간단하고 직관적인 구조를 가지고 있으며, 주어진 문제에 따라서는 최적해를 보장할 수 있다.

## 특징
그리디 알고리즘은 다음과 같은 특징을 가진다.

+ **간단하고 빠른 실행:** 구현이 간단하며, 일반적으로 다른 알고리즘보다 빠른 실행 속도를 가진다.
+ **최적해 보장 불가능:** 모든 문제에 대해 최적해를 보장하지는 않는다. 따라서 사용 가능한 경우와 문제의 특성을 고려하여 적절히 적용해야 한다.
+ **Greedy choice property를 만족해야 함:** 각 단계에서의 최적 선택이 전체적인 최적해에 기여해야 한다. 즉, 각 단계에서 지금 당장 최적인 선택을 하면서 문제를 부분적으로 해결하는 것이다.


## Implementation
다음은 동전 거스름돈 문제를 그리디 알고리즘을 사용하여 해결하는 예시다:

**동전 거스름돈 문제:** 거스름돈으로 사용할 동전의 종류가 주어졌을 때, 거슬러 줄 동전의 최소 개수를 구하는 문제다.

**알고리즘**
1. 거스름돈에서 가장 큰 가치의 동전을 선택한다.
2. 선택한 동전으로 거스름돈을 계속 나누어 나간다.

+ C++
  ```c++
  #include <iostream>
  #include <vector>
  using namespace std;
  
  vector<int> coins = {500, 100, 50, 10}; // 동전의 가치
  
  int minCoins(int change) {
      int count = 0;
      for (int coin : coins) {
          count += change / coin; // 현재 가치의 동전으로 거슬러 줄 수 있는 개수를 구함
          change %= coin; // 거슬러 준 후 남은 잔액을 계산
      }
      return count;
  }
  
  int main() {
      int change;
      cout << "거스름돈 금액을 입력하세요: ";
      cin >> change;
      cout << "최소 동전 개수: " << minCoins(change) << endl;
      return 0;
  }

  ```
**주의:** 위 거스름돈 문제가 그리디 알고리즘으로 풀이가 가능한 이유는, 주어진 동전을 보면 큰 단위의 동전은 항상 작은 단위의 배수이므로 작은 단위의 동전들의 조합으로 다른 해가 나올 수 없기 때문이다. 동전의 단위가 배수 관계가 아니라면 그리디 알고리즘으로 도출된 해는 최적의 해가 아닐 수 있다.
