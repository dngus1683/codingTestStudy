# 자료 구조
+ [queue](#queue)
+ [stack](stack)
+ [map](#map)
+ [deque](#deque)

+ 공통
  
  + **size()와 empty():** 반복문의 조건으로 'STL 컨테이너의 원소 유무'를 사용할 때, size()를 사용한다면 해당 컨테이너의 원소 개수를 직접 세야 하므로 시간 복잡도가 O(n)이 되며, 이는 시간 초과가 날 수 있다. 반면 empty()는 O(1)의 시간 복잡도를 가지므로 empty()를 사용하는 것이 시간적으로 경제적이다.
  
## queue
큐(Queue)는 데이터를 일시적으로 저장하는 자료 구조로, 데이터의 삽입은 한쪽 끝(rear 또는 back)에서 이루어지고, 데이터의 삭제는 반대쪽 끝(front 또는 head)에서 이루어지는 선입선출(FIFO, First-In-First-Out) 형태를 가지고 있다.

### Implementation
+ C++
  
   C++ 표준 라이브러리(STL)에서는 <queue> 헤더를 통해 큐를 지원하고 있습니다. 이를 이용하여 큐를 구현하고 사용할 수 있습니다.

  **C++ STL Queue 기능**
  
  **1. push():** 큐의 뒷쪽(rear)에 요소를 추가한다.
  
  **2. pop():** 큐의 앞쪽(front)에서 요소를 제거한다.
  
  **3. front():** 큐의 맨 앞에 있는 요소를 반환한다.
  
  **4. back():** 큐의 맨 뒤에 있는 요소를 반환한다.
  
  **5. empty():** 큐가 비어 있는지 확인한다.
  
  **6. size():** 큐에 저장된 요소의 개수를 반환한다.




## stack
스택(Stack)은 후입선출(LIFO, Last-In-First-Out) 방식으로 데이터를 저장하는 자료 구조다.

### Implementation
+ C++
  
  C++ 표준 라이브러리(STL)에서는 <stack> 헤더를 통해 스택을 지원하고 있으며, 이를 이용하여 스택을 구현하고 사용할 수 있다.

  **C++ STL Stack 기능**
  
  **1. push():** 스택의 맨 위(top)에 요소를 추가한다.
  
  **2. pop():** 스택의 맨 위(top)에서 요소를 제거한다.
  
  **3. top():** 스택의 맨 위에 있는 요소를 반환한다.
  
  **5. empty():** 스택이 비어 있는지 확인한다.

  **6. size():** 스택에 저장된 요소의 개수를 반환한다.


## map
맵(map)은 키(key)와 값(value)을 연관시켜 저장하는 자료 구조로, 키를 기준으로 값에 접근할 수 있다. 맵은 키-값 쌍을 저장하며, 각 키는 유일해야 한다. 맵은 키에 대한 자동 정렬을 제공하며, 이진 탐색 트리(Binary Search Tree) 기반으로 구현되어 있어 검색, 삽입, 삭제 등의 연산이 빠르다. 따라서 검색과 같은 기능의 시간 복잡도는 O(logn)이다.

### Implementation
+ C++
  C++ 표준 라이브러리(STL)에서는 <map> 헤더를 통해 맵을 지원하고 있으며, 이를 이용하여 맵을 구현하고 사용할 수 있다.
  
  **C++ STL Map 기능**
  
  **1. insert():** 맵에 새로운 요소를 추가한다.
  
  **2. erase():** 맵에서 특정 키를 가진 요소를 제거한다.
  
  **3. find():** 맵에서 특정 키를 검색한다.
  
  **4. count():** 맵에서 특정 키의 존재 여부를 확인한다.
  
  **5. size():** 맵에 저장된 요소의 개수를 반환한다.
  
  **6. empty():** 맵이 비어 있는지 확인한다.
  
  **7. begin(), end():** 맵의 시작과 끝을 가리키는 반복자(iterator)를 반환한다.


  + **값에 접근**

    find()함수는 특정 키를 검색해 해당 하는 키-값 쌍의 반복자 즉, 주소값을 반환한다. 때문에 해당 주소에 arrow 연산자(->)를 통해 키, 값에 접근한다.
      ```c++
      map<string, int> m;
      
      int key = m.find("apple")->first;
      int value = m.find("apple")->second;
      ```
  + **키 존재 유무**

     해당 맵에 특정 키 값이 존재하는 지 확인하기 위해서 find()와 end() 함수를 사용한다. find()는 특정 키를 검색했을 때, 해당 키가 맵에 존재하지 않는다면 end() 반복자를 반환한다.
      ```c++
      if(m.find("apple") != m.end()) cout << "apple 키 존재" << endl;
      else cout << "apple 키 없음" << endl;
      ```


## deque
덱(deque)은 Double-Ended Queue의 약어로, 큐(Queue)와 스택(Stack)의 특성을 모두 가지고 있는 자료 구조다. 덱은 양쪽 끝에서 삽입과 삭제가 모두 가능하며, 중간에 요소를 삽입하거나 삭제하는 것도 가능하다.

### Implementation
  + C++
    C++ 표준 라이브러리(STL)에서는 <deque> 헤더를 통해 덱을 지원하고 있으며, 이를 이용하여 덱을 구현하고 사용할 수 있다.

    **C++ STL Deque 기능**
  
    **1. push_back():** 덱의 뒤쪽에 요소를 추가한다.
    
    **2. push_front():** 덱의 앞쪽에 요소를 추가한다.
    
    **3. pop_back():** 덱의 뒤쪽에서 요소를 제거한다.
    
    **4. pop_front():** 덱의 앞쪽에서 요소를 제거한다.
    
    **5. back():** 덱의 마지막 요소를 반환한다.
    
    **6. front():** 덱의 첫 번째 요소를 반환한다.
    
    **7. size():** 덱에 저장된 요소의 개수를 반환한다.
    
    **8. empty():** 덱이 비어 있는지 여부를 확인한다.

    **9. insert():** 덱의 임의의 위치에 요소를 추가한다.


    + **덱 중간에 요소 추가**
      
      insert() 함수를 사용하여 중간에 요소를 삽입할 수 있다.
      ```c++
      #include <iostream>
      #include <deque>
      
      int main() {
          std::deque<int> dq = {1, 2, 4, 5};
      
          // 덱의 3번째 위치에 요소 3 삽입
          dq.insert(dq.begin() + 2, 3);
      
          // 덱 출력
          for (int x : dq) {
              std::cout << x << " ";
          }
          std::cout << std::endl;
      
          return 0;
      }
      ```
      
